package gha

import (
	"context"
	"crypto"
	"fmt"
	"os"

	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/sigstore/cosign/pkg/cosign"
	"github.com/sigstore/rekor/pkg/generated/client"
	"github.com/sigstore/rekor/pkg/generated/client/entries"
	"github.com/sigstore/rekor/pkg/generated/models"
	intotod "github.com/sigstore/rekor/pkg/types/intoto/v0.0.1"
	rverify "github.com/sigstore/rekor/pkg/verify"
	"github.com/sigstore/sigstore/pkg/signature"
	"github.com/slsa-framework/slsa-github-generator/signing/envelope"

	serrors "github.com/slsa-framework/slsa-verifier/errors"
)

const (
	defaultRekorAddr = "https://rekor.sigstore.dev"
)

func intotoEntry(certPem []byte, provenance []byte) (*intotod.V001Entry, error) {
	if len(certPem) == 0 {
		return nil, serrors.ErrorInvalidPEM
	}
	cert := strfmt.Base64(certPem)
	return &intotod.V001Entry{
		IntotoObj: models.IntotoV001Schema{
			Content: &models.IntotoV001SchemaContent{
				Envelope: string(provenance),
			},
			PublicKey: &cert,
		},
	}, nil
}

// GetRekorEntriesWithCert finds all entry UUIDs with the full intoto attestation.
// The attestation generated by the slsa-github-generator libraries contain a signing certificate.
func GetRekorEntriesWithCert(rClient *client.Rekor, provenance []byte) (
	*models.LogEntryAnon, error) {
	// Use intoto attestation to find rekor entry UUIDs.
	params := entries.NewSearchLogQueryParams()
	searchLogQuery := models.SearchLogQuery{}
	certPem, err := envelope.GetCertFromEnvelope(provenance)
	if err != nil {
		return nil, fmt.Errorf("%s: %w", err, serrors.ErrorInvalidDssePayload)
	}

	// Construct the proposed intoto entry
	e, err := intotoEntry(certPem, provenance)
	if err != nil {
		return nil, fmt.Errorf("error creating intoto entry: %w", err)
	}
	entry := models.Intoto{
		APIVersion: swag.String(e.APIVersion()),
		Spec:       e.IntotoObj,
	}
	entries := []models.ProposedEntry{&entry}
	searchLogQuery.SetEntries(entries)

	params.SetEntry(&searchLogQuery)
	resp, err := rClient.Entries.SearchLogQuery(params)
	if err != nil {
		return nil, fmt.Errorf("%w: %s", serrors.ErrorRekorSearch, err.Error())
	}

	if len(resp.GetPayload()) == 0 {
		return nil, fmt.Errorf("%w: %s", serrors.ErrorRekorSearch, "no matching rekor entries")
	}

	logEntry := resp.Payload[0]
	var verifiedEntry models.LogEntryAnon

	ctx := context.Background()
	rekorPubs, err := cosign.GetRekorPubs(ctx, rClient)
	if err != nil {
		return nil, fmt.Errorf("getting rekor pubs from TUF: %s", err)
	}

	// Validate the log entry.
	for uuid, e := range logEntry {
		pubKey, ok := rekorPubs[*e.LogID]
		if !ok {
			return nil, fmt.Errorf("missing rekor pubkey: %s", err)
		}
		verifier, err := signature.LoadVerifier(pubKey.PubKey, crypto.SHA256)
		if err != nil {
			return nil, fmt.Errorf("loading verifier for rekor key %s", err)
		}
		if err := rverify.VerifyLogEntry(context.Background(), &e, verifier); err != nil {
			return nil, fmt.Errorf("%w: %s", serrors.ErrorNoValidRekorEntries, err)
		}
		url := fmt.Sprintf("%v/%v/%v", defaultRekorAddr, "api/v1/log/entries", uuid)
		fmt.Fprintf(os.Stderr, "Verified signature against tlog entry index %d at URL: %s\n", *e.LogIndex, url)
		verifiedEntry = e
	}

	return &verifiedEntry, nil
}
